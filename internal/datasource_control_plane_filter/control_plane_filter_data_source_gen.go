// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_control_plane_filter

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ControlPlaneFilterDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the ControlPlaneFilter",
				MarkdownDescription: "name of the ControlPlaneFilter",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"entries": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:            true,
									Description:         "Description of the FilterEntry.",
									MarkdownDescription: "Description of the FilterEntry.",
								},
								"ip_entry": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"action": schema.StringAttribute{
											Optional:            true,
											Description:         "An action to take, either 'Accept','Drop', or 'RateLimit'.",
											MarkdownDescription: "An action to take, either 'Accept','Drop', or 'RateLimit'.",
										},
										"destination_port_name": schema.StringAttribute{
											Optional:            true,
											Description:         "Destination port to match by name.",
											MarkdownDescription: "Destination port to match by name.",
										},
										"destination_port_number": schema.Int64Attribute{
											Optional:            true,
											Description:         "Destination port to match by numerical value.",
											MarkdownDescription: "Destination port to match by numerical value.",
										},
										"destination_port_operator": schema.StringAttribute{
											Optional:            true,
											Description:         "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
											MarkdownDescription: "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
										},
										"destination_port_range": schema.StringAttribute{
											Optional:            true,
											Description:         "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
											MarkdownDescription: "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
										},
										"destination_prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "Destination prefix to match.",
											MarkdownDescription: "Destination prefix to match.",
										},
										"first_fragment": schema.BoolAttribute{
											Optional:            true,
											Description:         "Match the first fragment only.",
											MarkdownDescription: "Match the first fragment only.",
										},
										"fragment": schema.BoolAttribute{
											Optional:            true,
											Description:         "Match any fragment.",
											MarkdownDescription: "Match any fragment.",
										},
										"icmp_code": schema.ListAttribute{
											ElementType:         types.Int64Type,
											Optional:            true,
											Description:         "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
											MarkdownDescription: "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
										},
										"icmp_type_name": schema.StringAttribute{
											Optional:            true,
											Description:         "Match a specific ICMP type by name, e.g. dest-unreachable.",
											MarkdownDescription: "Match a specific ICMP type by name, e.g. dest-unreachable.",
										},
										"icmp_type_number": schema.Int64Attribute{
											Optional:            true,
											Description:         "Match a specific ICMP type by number.",
											MarkdownDescription: "Match a specific ICMP type by number.",
										},
										"log": schema.BoolAttribute{
											Optional:            true,
											Description:         "Log the matches for this entry.",
											MarkdownDescription: "Log the matches for this entry.",
										},
										"protocol_name": schema.StringAttribute{
											Optional:            true,
											Description:         "Match a specific IP protocol name (specified in the type field of the IP header).",
											MarkdownDescription: "Match a specific IP protocol name (specified in the type field of the IP header).",
										},
										"protocol_number": schema.Int64Attribute{
											Optional:            true,
											Description:         "Match a specific IP protocol number (specified in the type field of the IP header).",
											MarkdownDescription: "Match a specific IP protocol number (specified in the type field of the IP header).",
										},
										"rate_limit": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"burst_size": schema.Int64Attribute{
													Optional:            true,
													Description:         "The maximum burst size in bytes.",
													MarkdownDescription: "The maximum burst size in bytes.",
												},
												"entry_specific_policer": schema.BoolAttribute{
													Optional:            true,
													Description:         "Controls policer instantiation: false for shared instance, true for per-entry instances",
													MarkdownDescription: "Controls policer instantiation: false for shared instance, true for per-entry instances",
												},
												"peak_rate": schema.Int64Attribute{
													Optional:            true,
													Description:         "The peak rate in kilobytes per second.",
													MarkdownDescription: "The peak rate in kilobytes per second.",
												},
												"scope": schema.StringAttribute{
													Optional:            true,
													Description:         "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
													MarkdownDescription: "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
												},
											},
											CustomType: RateLimitType{
												ObjectType: types.ObjectType{
													AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Rate limit to apply when the action is 'RateLimit'.",
											MarkdownDescription: "Rate limit to apply when the action is 'RateLimit'.",
										},
										"source_port_name": schema.StringAttribute{
											Optional:            true,
											Description:         "Source port to match by name.",
											MarkdownDescription: "Source port to match by name.",
										},
										"source_port_number": schema.Int64Attribute{
											Optional:            true,
											Description:         "Source port to match by numerical value.",
											MarkdownDescription: "Source port to match by numerical value.",
										},
										"source_port_operator": schema.StringAttribute{
											Optional:            true,
											Description:         "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
											MarkdownDescription: "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
										},
										"source_port_range": schema.StringAttribute{
											Optional:            true,
											Description:         "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
											MarkdownDescription: "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
										},
										"source_prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "Source prefix to match.",
											MarkdownDescription: "Source prefix to match.",
										},
										"tcp_flags": schema.StringAttribute{
											Optional:            true,
											Description:         "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
											MarkdownDescription: "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
										},
									},
									CustomType: IpEntryType{
										ObjectType: types.ObjectType{
											AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"mac_entry": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"action": schema.StringAttribute{
											Optional:            true,
											Description:         "An action to take, either 'Accept','Drop', or 'RateLimit'.",
											MarkdownDescription: "An action to take, either 'Accept','Drop', or 'RateLimit'.",
										},
										"destination_mac": schema.StringAttribute{
											Optional:            true,
											Description:         "Match an Ethernet frame if its destination MAC address logically anded with the mask equals this MAC address.",
											MarkdownDescription: "Match an Ethernet frame if its destination MAC address logically anded with the mask equals this MAC address.",
										},
										"destination_macmask": schema.StringAttribute{
											Optional:            true,
											Description:         "Match an Ethernet frame if its destination MAC address logically anded with the mask equals the configured MAC address.",
											MarkdownDescription: "Match an Ethernet frame if its destination MAC address logically anded with the mask equals the configured MAC address.",
										},
										"ethertype": schema.StringAttribute{
											Optional:            true,
											Description:         "An Ethernet frame matches this condition if its ethertype value (after 802.1Q VLAN tags) matches the specified value.",
											MarkdownDescription: "An Ethernet frame matches this condition if its ethertype value (after 802.1Q VLAN tags) matches the specified value.",
										},
										"log": schema.BoolAttribute{
											Optional:            true,
											Description:         "Log the matches for this entry.",
											MarkdownDescription: "Log the matches for this entry.",
										},
										"outer_vlanidoperator": schema.StringAttribute{
											Optional:            true,
											Description:         "Operator to use when matching OuterVlanIdValue, either Equals, GreaterOrEquals, or LessOrEquals.",
											MarkdownDescription: "Operator to use when matching OuterVlanIdValue, either Equals, GreaterOrEquals, or LessOrEquals.",
										},
										"outer_vlanidrange": schema.StringAttribute{
											Optional:            true,
											Description:         "Range of Outer vlan IDs to match, in the format n-m, e.g. 100-200",
											MarkdownDescription: "Range of Outer vlan IDs to match, in the format n-m, e.g. 100-200",
										},
										"outer_vlanidvalue": schema.StringAttribute{
											Optional:            true,
											Description:         "Ethernet frame matching criteria based on the outermost VLAN ID found before the subinterface-defining VLAN tag (if any) is removed. A value of 'none' will match only untagged frames.",
											MarkdownDescription: "Ethernet frame matching criteria based on the outermost VLAN ID found before the subinterface-defining VLAN tag (if any) is removed. A value of 'none' will match only untagged frames.",
										},
										"rate_limit_1": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"burst_size": schema.Int64Attribute{
													Optional:            true,
													Description:         "The maximum burst size in bytes.",
													MarkdownDescription: "The maximum burst size in bytes.",
												},
												"entry_specific_policer": schema.BoolAttribute{
													Optional:            true,
													Description:         "Controls policer instantiation: false for shared instance, true for per-entry instances",
													MarkdownDescription: "Controls policer instantiation: false for shared instance, true for per-entry instances",
												},
												"peak_rate": schema.Int64Attribute{
													Optional:            true,
													Description:         "The peak rate in kilobytes per second.",
													MarkdownDescription: "The peak rate in kilobytes per second.",
												},
												"scope": schema.StringAttribute{
													Optional:            true,
													Description:         "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
													MarkdownDescription: "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
												},
											},
											CustomType: RateLimit1Type{
												ObjectType: types.ObjectType{
													AttrTypes: RateLimit1Value{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Rate limit to apply when the action is 'RateLimit'.",
											MarkdownDescription: "Rate limit to apply when the action is 'RateLimit'.",
										},
										"source_mac": schema.StringAttribute{
											Optional:            true,
											Description:         "Match an Ethernet frame if its source MAC address logically anded with the mask equals this MAC address.",
											MarkdownDescription: "Match an Ethernet frame if its source MAC address logically anded with the mask equals this MAC address.",
										},
										"source_macmask": schema.StringAttribute{
											Optional:            true,
											Description:         "Match an Ethernet frame if its source MAC address logically anded with the mask equals the configured MAC address.",
											MarkdownDescription: "Match an Ethernet frame if its source MAC address logically anded with the mask equals the configured MAC address.",
										},
									},
									CustomType: MacEntryType{
										ObjectType: types.ObjectType{
											AttrTypes: MacEntryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Description:         "Type of the entry which can be IPV4, IPV6, MAC or Auto.",
									MarkdownDescription: "Type of the entry which can be IPV4, IPV6, MAC or Auto.",
								},
							},
							CustomType: EntriesType{
								ObjectType: types.ObjectType{
									AttrTypes: EntriesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Specifies the list of filter entries, in order.",
						MarkdownDescription: "Specifies the list of filter entries, in order.",
					},
					"node_selector": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Label selector used to select Toponodes on which to deploy the CPM filter.",
						MarkdownDescription: "Label selector used to select Toponodes on which to deploy the CPM filter.",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to a list of TopoNodes on which to deploy the CPM filter.",
						MarkdownDescription: "Reference to a list of TopoNodes on which to deploy the CPM filter.",
					},
					"statistics_per_entry": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable or disable per-entry counters.",
						MarkdownDescription: "Enable or disable per-entry counters.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "ControlPlaneFilter allows for specifying a list of Nodes or Node selectors where the filter should be applied and managing filter entries in order.",
				MarkdownDescription: "ControlPlaneFilter allows for specifying a list of Nodes or Node selectors where the filter should be applied and managing filter entries in order.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ControlPlaneFilterStatus defines the observed state of ControlPlaneFilter",
				MarkdownDescription: "ControlPlaneFilterStatus defines the observed state of ControlPlaneFilter",
			},
		},
	}
}

type ControlPlaneFilterModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return nil, diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	statisticsPerEntryAttribute, ok := attributes["statistics_per_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics_per_entry is missing from object`)

		return nil, diags
	}

	statisticsPerEntryVal, ok := statisticsPerEntryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics_per_entry expected to be basetypes.BoolValue, was: %T`, statisticsPerEntryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Entries:            entriesVal,
		NodeSelector:       nodeSelectorVal,
		Nodes:              nodesVal,
		StatisticsPerEntry: statisticsPerEntryVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	statisticsPerEntryAttribute, ok := attributes["statistics_per_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics_per_entry is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	statisticsPerEntryVal, ok := statisticsPerEntryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics_per_entry expected to be basetypes.BoolValue, was: %T`, statisticsPerEntryAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Entries:            entriesVal,
		NodeSelector:       nodeSelectorVal,
		Nodes:              nodesVal,
		StatisticsPerEntry: statisticsPerEntryVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Entries            basetypes.ListValue `tfsdk:"entries"`
	NodeSelector       basetypes.ListValue `tfsdk:"node_selector"`
	Nodes              basetypes.ListValue `tfsdk:"nodes"`
	StatisticsPerEntry basetypes.BoolValue `tfsdk:"statistics_per_entry"`
	state              attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["entries"] = basetypes.ListType{
		ElemType: EntriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["statistics_per_entry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Entries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entries"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.StatisticsPerEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statistics_per_entry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	entries := types.ListValueMust(
		EntriesType{
			basetypes.ObjectType{
				AttrTypes: EntriesValue{}.AttributeTypes(ctx),
			},
		},
		v.Entries.Elements(),
	)

	if v.Entries.IsNull() {
		entries = types.ListNull(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Entries.IsUnknown() {
		entries = types.ListUnknown(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeSelectorVal basetypes.ListValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.ListUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.ListValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"entries": basetypes.ListType{
				ElemType: EntriesValue{}.Type(ctx),
			},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"statistics_per_entry": basetypes.BoolType{},
		}), diags
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"entries": basetypes.ListType{
				ElemType: EntriesValue{}.Type(ctx),
			},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"statistics_per_entry": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"statistics_per_entry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"entries":              entries,
			"node_selector":        nodeSelectorVal,
			"nodes":                nodesVal,
			"statistics_per_entry": v.StatisticsPerEntry,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Entries.Equal(other.Entries) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.StatisticsPerEntry.Equal(other.StatisticsPerEntry) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"statistics_per_entry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = EntriesType{}

type EntriesType struct {
	basetypes.ObjectType
}

func (t EntriesType) Equal(o attr.Type) bool {
	other, ok := o.(EntriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EntriesType) String() string {
	return "EntriesType"
}

func (t EntriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return nil, diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	macEntryAttribute, ok := attributes["mac_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_entry is missing from object`)

		return nil, diags
	}

	macEntryVal, ok := macEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_entry expected to be basetypes.ObjectValue, was: %T`, macEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EntriesValue{
		Description: descriptionVal,
		IpEntry:     ipEntryVal,
		MacEntry:    macEntryVal,
		EntriesType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueNull() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateNull,
	}
}

func NewEntriesValueUnknown() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEntriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EntriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EntriesValue Attribute Value",
				"While creating a EntriesValue value, a missing attribute value was detected. "+
					"A EntriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EntriesValue Attribute Type",
				"While creating a EntriesValue value, an invalid attribute value was detected. "+
					"A EntriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EntriesValue Attribute Value",
				"While creating a EntriesValue value, an extra attribute value was detected. "+
					"A EntriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EntriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	macEntryAttribute, ok := attributes["mac_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	macEntryVal, ok := macEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_entry expected to be basetypes.ObjectValue, was: %T`, macEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	return EntriesValue{
		Description: descriptionVal,
		IpEntry:     ipEntryVal,
		MacEntry:    macEntryVal,
		EntriesType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EntriesValue {
	object, diags := NewEntriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEntriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EntriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEntriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEntriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEntriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEntriesValueMust(EntriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EntriesType) ValueType(ctx context.Context) attr.Value {
	return EntriesValue{}
}

var _ basetypes.ObjectValuable = EntriesValue{}

type EntriesValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	IpEntry     basetypes.ObjectValue `tfsdk:"ip_entry"`
	MacEntry    basetypes.ObjectValue `tfsdk:"mac_entry"`
	EntriesType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v EntriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_entry"] = basetypes.ObjectType{
		AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_entry"] = basetypes.ObjectType{
		AttrTypes: MacEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.IpEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_entry"] = val

		val, err = v.MacEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_entry"] = val

		val, err = v.EntriesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EntriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EntriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EntriesValue) String() string {
	return "EntriesValue"
}

func (v EntriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipEntry basetypes.ObjectValue

	if v.IpEntry.IsNull() {
		ipEntry = types.ObjectNull(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectUnknown(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpEntry.IsNull() && !v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectValueMust(
			IpEntryValue{}.AttributeTypes(ctx),
			v.IpEntry.Attributes(),
		)
	}

	var macEntry basetypes.ObjectValue

	if v.MacEntry.IsNull() {
		macEntry = types.ObjectNull(
			MacEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.MacEntry.IsUnknown() {
		macEntry = types.ObjectUnknown(
			MacEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MacEntry.IsNull() && !v.MacEntry.IsUnknown() {
		macEntry = types.ObjectValueMust(
			MacEntryValue{}.AttributeTypes(ctx),
			v.MacEntry.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"mac_entry": basetypes.ObjectType{
			AttrTypes: MacEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"ip_entry":    ipEntry,
			"mac_entry":   macEntry,
			"type":        v.EntriesType,
		})

	return objVal, diags
}

func (v EntriesValue) Equal(o attr.Value) bool {
	other, ok := o.(EntriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.IpEntry.Equal(other.IpEntry) {
		return false
	}

	if !v.MacEntry.Equal(other.MacEntry) {
		return false
	}

	if !v.EntriesType.Equal(other.EntriesType) {
		return false
	}

	return true
}

func (v EntriesValue) Type(ctx context.Context) attr.Type {
	return EntriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EntriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"mac_entry": basetypes.ObjectType{
			AttrTypes: MacEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpEntryType{}

type IpEntryType struct {
	basetypes.ObjectType
}

func (t IpEntryType) Equal(o attr.Type) bool {
	other, ok := o.(IpEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpEntryType) String() string {
	return "IpEntryType"
}

func (t IpEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return nil, diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return nil, diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return nil, diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return nil, diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return nil, diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return nil, diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return nil, diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return nil, diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return nil, diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return nil, diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return nil, diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return nil, diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return nil, diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	rateLimitAttribute, ok := attributes["rate_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit is missing from object`)

		return nil, diags
	}

	rateLimitVal, ok := rateLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit expected to be basetypes.ObjectValue, was: %T`, rateLimitAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return nil, diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return nil, diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return nil, diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return nil, diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return nil, diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return nil, diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		Log:                     logVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		RateLimit:               rateLimitVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueNull() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewIpEntryValueUnknown() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, a missing attribute value was detected. "+
					"A IpEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpEntryValue Attribute Type",
				"While creating a IpEntryValue value, an invalid attribute value was detected. "+
					"A IpEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, an extra attribute value was detected. "+
					"A IpEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	rateLimitAttribute, ok := attributes["rate_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	rateLimitVal, ok := rateLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit expected to be basetypes.ObjectValue, was: %T`, rateLimitAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		Log:                     logVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		RateLimit:               rateLimitVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpEntryValue {
	object, diags := NewIpEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpEntryValueMust(IpEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpEntryType) ValueType(ctx context.Context) attr.Value {
	return IpEntryValue{}
}

var _ basetypes.ObjectValuable = IpEntryValue{}

type IpEntryValue struct {
	Action                  basetypes.StringValue `tfsdk:"action"`
	DestinationPortName     basetypes.StringValue `tfsdk:"destination_port_name"`
	DestinationPortNumber   basetypes.Int64Value  `tfsdk:"destination_port_number"`
	DestinationPortOperator basetypes.StringValue `tfsdk:"destination_port_operator"`
	DestinationPortRange    basetypes.StringValue `tfsdk:"destination_port_range"`
	DestinationPrefix       basetypes.StringValue `tfsdk:"destination_prefix"`
	FirstFragment           basetypes.BoolValue   `tfsdk:"first_fragment"`
	Fragment                basetypes.BoolValue   `tfsdk:"fragment"`
	IcmpCode                basetypes.ListValue   `tfsdk:"icmp_code"`
	IcmpTypeName            basetypes.StringValue `tfsdk:"icmp_type_name"`
	IcmpTypeNumber          basetypes.Int64Value  `tfsdk:"icmp_type_number"`
	Log                     basetypes.BoolValue   `tfsdk:"log"`
	ProtocolName            basetypes.StringValue `tfsdk:"protocol_name"`
	ProtocolNumber          basetypes.Int64Value  `tfsdk:"protocol_number"`
	RateLimit               basetypes.ObjectValue `tfsdk:"rate_limit"`
	SourcePortName          basetypes.StringValue `tfsdk:"source_port_name"`
	SourcePortNumber        basetypes.Int64Value  `tfsdk:"source_port_number"`
	SourcePortOperator      basetypes.StringValue `tfsdk:"source_port_operator"`
	SourcePortRange         basetypes.StringValue `tfsdk:"source_port_range"`
	SourcePrefix            basetypes.StringValue `tfsdk:"source_prefix"`
	TcpFlags                basetypes.StringValue `tfsdk:"tcp_flags"`
	state                   attr.ValueState
}

func (v IpEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["destination_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["first_fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["icmp_code"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["icmp_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["icmp_type_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["log"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["protocol_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate_limit"] = basetypes.ObjectType{
		AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["source_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["source_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tcp_flags"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DestinationPortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_name"] = val

		val, err = v.DestinationPortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_number"] = val

		val, err = v.DestinationPortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_operator"] = val

		val, err = v.DestinationPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_range"] = val

		val, err = v.DestinationPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_prefix"] = val

		val, err = v.FirstFragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["first_fragment"] = val

		val, err = v.Fragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fragment"] = val

		val, err = v.IcmpCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_code"] = val

		val, err = v.IcmpTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_name"] = val

		val, err = v.IcmpTypeNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_number"] = val

		val, err = v.Log.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log"] = val

		val, err = v.ProtocolName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_name"] = val

		val, err = v.ProtocolNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_number"] = val

		val, err = v.RateLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate_limit"] = val

		val, err = v.SourcePortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_name"] = val

		val, err = v.SourcePortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_number"] = val

		val, err = v.SourcePortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_operator"] = val

		val, err = v.SourcePortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_range"] = val

		val, err = v.SourcePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_prefix"] = val

		val, err = v.TcpFlags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tcp_flags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpEntryValue) String() string {
	return "IpEntryValue"
}

func (v IpEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var rateLimit basetypes.ObjectValue

	if v.RateLimit.IsNull() {
		rateLimit = types.ObjectNull(
			RateLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.RateLimit.IsUnknown() {
		rateLimit = types.ObjectUnknown(
			RateLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RateLimit.IsNull() && !v.RateLimit.IsUnknown() {
		rateLimit = types.ObjectValueMust(
			RateLimitValue{}.AttributeTypes(ctx),
			v.RateLimit.Attributes(),
		)
	}

	var icmpCodeVal basetypes.ListValue
	switch {
	case v.IcmpCode.IsUnknown():
		icmpCodeVal = types.ListUnknown(types.Int64Type)
	case v.IcmpCode.IsNull():
		icmpCodeVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		icmpCodeVal, d = types.ListValue(types.Int64Type, v.IcmpCode.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action":                    basetypes.StringType{},
			"destination_port_name":     basetypes.StringType{},
			"destination_port_number":   basetypes.Int64Type{},
			"destination_port_operator": basetypes.StringType{},
			"destination_port_range":    basetypes.StringType{},
			"destination_prefix":        basetypes.StringType{},
			"first_fragment":            basetypes.BoolType{},
			"fragment":                  basetypes.BoolType{},
			"icmp_code": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"icmp_type_name":   basetypes.StringType{},
			"icmp_type_number": basetypes.Int64Type{},
			"log":              basetypes.BoolType{},
			"protocol_name":    basetypes.StringType{},
			"protocol_number":  basetypes.Int64Type{},
			"rate_limit": basetypes.ObjectType{
				AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
			},
			"source_port_name":     basetypes.StringType{},
			"source_port_number":   basetypes.Int64Type{},
			"source_port_operator": basetypes.StringType{},
			"source_port_range":    basetypes.StringType{},
			"source_prefix":        basetypes.StringType{},
			"tcp_flags":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action":                    basetypes.StringType{},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"first_fragment":            basetypes.BoolType{},
		"fragment":                  basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":   basetypes.StringType{},
		"icmp_type_number": basetypes.Int64Type{},
		"log":              basetypes.BoolType{},
		"protocol_name":    basetypes.StringType{},
		"protocol_number":  basetypes.Int64Type{},
		"rate_limit": basetypes.ObjectType{
			AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
		},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":                    v.Action,
			"destination_port_name":     v.DestinationPortName,
			"destination_port_number":   v.DestinationPortNumber,
			"destination_port_operator": v.DestinationPortOperator,
			"destination_port_range":    v.DestinationPortRange,
			"destination_prefix":        v.DestinationPrefix,
			"first_fragment":            v.FirstFragment,
			"fragment":                  v.Fragment,
			"icmp_code":                 icmpCodeVal,
			"icmp_type_name":            v.IcmpTypeName,
			"icmp_type_number":          v.IcmpTypeNumber,
			"log":                       v.Log,
			"protocol_name":             v.ProtocolName,
			"protocol_number":           v.ProtocolNumber,
			"rate_limit":                rateLimit,
			"source_port_name":          v.SourcePortName,
			"source_port_number":        v.SourcePortNumber,
			"source_port_operator":      v.SourcePortOperator,
			"source_port_range":         v.SourcePortRange,
			"source_prefix":             v.SourcePrefix,
			"tcp_flags":                 v.TcpFlags,
		})

	return objVal, diags
}

func (v IpEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(IpEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DestinationPortName.Equal(other.DestinationPortName) {
		return false
	}

	if !v.DestinationPortNumber.Equal(other.DestinationPortNumber) {
		return false
	}

	if !v.DestinationPortOperator.Equal(other.DestinationPortOperator) {
		return false
	}

	if !v.DestinationPortRange.Equal(other.DestinationPortRange) {
		return false
	}

	if !v.DestinationPrefix.Equal(other.DestinationPrefix) {
		return false
	}

	if !v.FirstFragment.Equal(other.FirstFragment) {
		return false
	}

	if !v.Fragment.Equal(other.Fragment) {
		return false
	}

	if !v.IcmpCode.Equal(other.IcmpCode) {
		return false
	}

	if !v.IcmpTypeName.Equal(other.IcmpTypeName) {
		return false
	}

	if !v.IcmpTypeNumber.Equal(other.IcmpTypeNumber) {
		return false
	}

	if !v.Log.Equal(other.Log) {
		return false
	}

	if !v.ProtocolName.Equal(other.ProtocolName) {
		return false
	}

	if !v.ProtocolNumber.Equal(other.ProtocolNumber) {
		return false
	}

	if !v.RateLimit.Equal(other.RateLimit) {
		return false
	}

	if !v.SourcePortName.Equal(other.SourcePortName) {
		return false
	}

	if !v.SourcePortNumber.Equal(other.SourcePortNumber) {
		return false
	}

	if !v.SourcePortOperator.Equal(other.SourcePortOperator) {
		return false
	}

	if !v.SourcePortRange.Equal(other.SourcePortRange) {
		return false
	}

	if !v.SourcePrefix.Equal(other.SourcePrefix) {
		return false
	}

	if !v.TcpFlags.Equal(other.TcpFlags) {
		return false
	}

	return true
}

func (v IpEntryValue) Type(ctx context.Context) attr.Type {
	return IpEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":                    basetypes.StringType{},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"first_fragment":            basetypes.BoolType{},
		"fragment":                  basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":   basetypes.StringType{},
		"icmp_type_number": basetypes.Int64Type{},
		"log":              basetypes.BoolType{},
		"protocol_name":    basetypes.StringType{},
		"protocol_number":  basetypes.Int64Type{},
		"rate_limit": basetypes.ObjectType{
			AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
		},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RateLimitType{}

type RateLimitType struct {
	basetypes.ObjectType
}

func (t RateLimitType) Equal(o attr.Type) bool {
	other, ok := o.(RateLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RateLimitType) String() string {
	return "RateLimitType"
}

func (t RateLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return nil, diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return nil, diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return nil, diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RateLimitValue{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimitValueNull() RateLimitValue {
	return RateLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewRateLimitValueUnknown() RateLimitValue {
	return RateLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRateLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RateLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RateLimitValue Attribute Value",
				"While creating a RateLimitValue value, a missing attribute value was detected. "+
					"A RateLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RateLimitValue Attribute Type",
				"While creating a RateLimitValue value, an invalid attribute value was detected. "+
					"A RateLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RateLimitValue Attribute Value",
				"While creating a RateLimitValue value, an extra attribute value was detected. "+
					"A RateLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RateLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRateLimitValueUnknown(), diags
	}

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewRateLimitValueUnknown(), diags
	}

	return RateLimitValue{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RateLimitValue {
	object, diags := NewRateLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRateLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RateLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRateLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRateLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRateLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRateLimitValueMust(RateLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RateLimitType) ValueType(ctx context.Context) attr.Value {
	return RateLimitValue{}
}

var _ basetypes.ObjectValuable = RateLimitValue{}

type RateLimitValue struct {
	BurstSize            basetypes.Int64Value  `tfsdk:"burst_size"`
	EntrySpecificPolicer basetypes.BoolValue   `tfsdk:"entry_specific_policer"`
	PeakRate             basetypes.Int64Value  `tfsdk:"peak_rate"`
	Scope                basetypes.StringValue `tfsdk:"scope"`
	state                attr.ValueState
}

func (v RateLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["entry_specific_policer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["peak_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.BurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["burst_size"] = val

		val, err = v.EntrySpecificPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entry_specific_policer"] = val

		val, err = v.PeakRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peak_rate"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RateLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RateLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RateLimitValue) String() string {
	return "RateLimitValue"
}

func (v RateLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"burst_size":             v.BurstSize,
			"entry_specific_policer": v.EntrySpecificPolicer,
			"peak_rate":              v.PeakRate,
			"scope":                  v.Scope,
		})

	return objVal, diags
}

func (v RateLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(RateLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BurstSize.Equal(other.BurstSize) {
		return false
	}

	if !v.EntrySpecificPolicer.Equal(other.EntrySpecificPolicer) {
		return false
	}

	if !v.PeakRate.Equal(other.PeakRate) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v RateLimitValue) Type(ctx context.Context) attr.Type {
	return RateLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RateLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MacEntryType{}

type MacEntryType struct {
	basetypes.ObjectType
}

func (t MacEntryType) Equal(o attr.Type) bool {
	other, ok := o.(MacEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MacEntryType) String() string {
	return "MacEntryType"
}

func (t MacEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationMacAttribute, ok := attributes["destination_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_mac is missing from object`)

		return nil, diags
	}

	destinationMacVal, ok := destinationMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_mac expected to be basetypes.StringValue, was: %T`, destinationMacAttribute))
	}

	destinationMacmaskAttribute, ok := attributes["destination_macmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_macmask is missing from object`)

		return nil, diags
	}

	destinationMacmaskVal, ok := destinationMacmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_macmask expected to be basetypes.StringValue, was: %T`, destinationMacmaskAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return nil, diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	outerVlanidoperatorAttribute, ok := attributes["outer_vlanidoperator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidoperator is missing from object`)

		return nil, diags
	}

	outerVlanidoperatorVal, ok := outerVlanidoperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidoperator expected to be basetypes.StringValue, was: %T`, outerVlanidoperatorAttribute))
	}

	outerVlanidrangeAttribute, ok := attributes["outer_vlanidrange"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidrange is missing from object`)

		return nil, diags
	}

	outerVlanidrangeVal, ok := outerVlanidrangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidrange expected to be basetypes.StringValue, was: %T`, outerVlanidrangeAttribute))
	}

	outerVlanidvalueAttribute, ok := attributes["outer_vlanidvalue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidvalue is missing from object`)

		return nil, diags
	}

	outerVlanidvalueVal, ok := outerVlanidvalueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidvalue expected to be basetypes.StringValue, was: %T`, outerVlanidvalueAttribute))
	}

	rateLimit1Attribute, ok := attributes["rate_limit_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit_1 is missing from object`)

		return nil, diags
	}

	rateLimit1Val, ok := rateLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit_1 expected to be basetypes.ObjectValue, was: %T`, rateLimit1Attribute))
	}

	sourceMacAttribute, ok := attributes["source_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_mac is missing from object`)

		return nil, diags
	}

	sourceMacVal, ok := sourceMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_mac expected to be basetypes.StringValue, was: %T`, sourceMacAttribute))
	}

	sourceMacmaskAttribute, ok := attributes["source_macmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_macmask is missing from object`)

		return nil, diags
	}

	sourceMacmaskVal, ok := sourceMacmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_macmask expected to be basetypes.StringValue, was: %T`, sourceMacmaskAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MacEntryValue{
		Action:              actionVal,
		DestinationMac:      destinationMacVal,
		DestinationMacmask:  destinationMacmaskVal,
		Ethertype:           ethertypeVal,
		Log:                 logVal,
		OuterVlanidoperator: outerVlanidoperatorVal,
		OuterVlanidrange:    outerVlanidrangeVal,
		OuterVlanidvalue:    outerVlanidvalueVal,
		RateLimit1:          rateLimit1Val,
		SourceMac:           sourceMacVal,
		SourceMacmask:       sourceMacmaskVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMacEntryValueNull() MacEntryValue {
	return MacEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewMacEntryValueUnknown() MacEntryValue {
	return MacEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMacEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MacEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MacEntryValue Attribute Value",
				"While creating a MacEntryValue value, a missing attribute value was detected. "+
					"A MacEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MacEntryValue Attribute Type",
				"While creating a MacEntryValue value, an invalid attribute value was detected. "+
					"A MacEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MacEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MacEntryValue Attribute Value",
				"While creating a MacEntryValue value, an extra attribute value was detected. "+
					"A MacEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MacEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMacEntryValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationMacAttribute, ok := attributes["destination_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_mac is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	destinationMacVal, ok := destinationMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_mac expected to be basetypes.StringValue, was: %T`, destinationMacAttribute))
	}

	destinationMacmaskAttribute, ok := attributes["destination_macmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_macmask is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	destinationMacmaskVal, ok := destinationMacmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_macmask expected to be basetypes.StringValue, was: %T`, destinationMacmaskAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	outerVlanidoperatorAttribute, ok := attributes["outer_vlanidoperator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidoperator is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	outerVlanidoperatorVal, ok := outerVlanidoperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidoperator expected to be basetypes.StringValue, was: %T`, outerVlanidoperatorAttribute))
	}

	outerVlanidrangeAttribute, ok := attributes["outer_vlanidrange"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidrange is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	outerVlanidrangeVal, ok := outerVlanidrangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidrange expected to be basetypes.StringValue, was: %T`, outerVlanidrangeAttribute))
	}

	outerVlanidvalueAttribute, ok := attributes["outer_vlanidvalue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlanidvalue is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	outerVlanidvalueVal, ok := outerVlanidvalueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlanidvalue expected to be basetypes.StringValue, was: %T`, outerVlanidvalueAttribute))
	}

	rateLimit1Attribute, ok := attributes["rate_limit_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit_1 is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	rateLimit1Val, ok := rateLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit_1 expected to be basetypes.ObjectValue, was: %T`, rateLimit1Attribute))
	}

	sourceMacAttribute, ok := attributes["source_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_mac is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	sourceMacVal, ok := sourceMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_mac expected to be basetypes.StringValue, was: %T`, sourceMacAttribute))
	}

	sourceMacmaskAttribute, ok := attributes["source_macmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_macmask is missing from object`)

		return NewMacEntryValueUnknown(), diags
	}

	sourceMacmaskVal, ok := sourceMacmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_macmask expected to be basetypes.StringValue, was: %T`, sourceMacmaskAttribute))
	}

	if diags.HasError() {
		return NewMacEntryValueUnknown(), diags
	}

	return MacEntryValue{
		Action:              actionVal,
		DestinationMac:      destinationMacVal,
		DestinationMacmask:  destinationMacmaskVal,
		Ethertype:           ethertypeVal,
		Log:                 logVal,
		OuterVlanidoperator: outerVlanidoperatorVal,
		OuterVlanidrange:    outerVlanidrangeVal,
		OuterVlanidvalue:    outerVlanidvalueVal,
		RateLimit1:          rateLimit1Val,
		SourceMac:           sourceMacVal,
		SourceMacmask:       sourceMacmaskVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMacEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MacEntryValue {
	object, diags := NewMacEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMacEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MacEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMacEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMacEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMacEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMacEntryValueMust(MacEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MacEntryType) ValueType(ctx context.Context) attr.Value {
	return MacEntryValue{}
}

var _ basetypes.ObjectValuable = MacEntryValue{}

type MacEntryValue struct {
	Action              basetypes.StringValue `tfsdk:"action"`
	DestinationMac      basetypes.StringValue `tfsdk:"destination_mac"`
	DestinationMacmask  basetypes.StringValue `tfsdk:"destination_macmask"`
	Ethertype           basetypes.StringValue `tfsdk:"ethertype"`
	Log                 basetypes.BoolValue   `tfsdk:"log"`
	OuterVlanidoperator basetypes.StringValue `tfsdk:"outer_vlanidoperator"`
	OuterVlanidrange    basetypes.StringValue `tfsdk:"outer_vlanidrange"`
	OuterVlanidvalue    basetypes.StringValue `tfsdk:"outer_vlanidvalue"`
	RateLimit1          basetypes.ObjectValue `tfsdk:"rate_limit_1"`
	SourceMac           basetypes.StringValue `tfsdk:"source_mac"`
	SourceMacmask       basetypes.StringValue `tfsdk:"source_macmask"`
	state               attr.ValueState
}

func (v MacEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_macmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["log"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["outer_vlanidoperator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["outer_vlanidrange"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["outer_vlanidvalue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate_limit_1"] = basetypes.ObjectType{
		AttrTypes: RateLimit1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["source_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_macmask"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DestinationMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_mac"] = val

		val, err = v.DestinationMacmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_macmask"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.Log.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log"] = val

		val, err = v.OuterVlanidoperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlanidoperator"] = val

		val, err = v.OuterVlanidrange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlanidrange"] = val

		val, err = v.OuterVlanidvalue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlanidvalue"] = val

		val, err = v.RateLimit1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate_limit_1"] = val

		val, err = v.SourceMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_mac"] = val

		val, err = v.SourceMacmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_macmask"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MacEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MacEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MacEntryValue) String() string {
	return "MacEntryValue"
}

func (v MacEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var rateLimit1 basetypes.ObjectValue

	if v.RateLimit1.IsNull() {
		rateLimit1 = types.ObjectNull(
			RateLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if v.RateLimit1.IsUnknown() {
		rateLimit1 = types.ObjectUnknown(
			RateLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RateLimit1.IsNull() && !v.RateLimit1.IsUnknown() {
		rateLimit1 = types.ObjectValueMust(
			RateLimit1Value{}.AttributeTypes(ctx),
			v.RateLimit1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action":               basetypes.StringType{},
		"destination_mac":      basetypes.StringType{},
		"destination_macmask":  basetypes.StringType{},
		"ethertype":            basetypes.StringType{},
		"log":                  basetypes.BoolType{},
		"outer_vlanidoperator": basetypes.StringType{},
		"outer_vlanidrange":    basetypes.StringType{},
		"outer_vlanidvalue":    basetypes.StringType{},
		"rate_limit_1": basetypes.ObjectType{
			AttrTypes: RateLimit1Value{}.AttributeTypes(ctx),
		},
		"source_mac":     basetypes.StringType{},
		"source_macmask": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":               v.Action,
			"destination_mac":      v.DestinationMac,
			"destination_macmask":  v.DestinationMacmask,
			"ethertype":            v.Ethertype,
			"log":                  v.Log,
			"outer_vlanidoperator": v.OuterVlanidoperator,
			"outer_vlanidrange":    v.OuterVlanidrange,
			"outer_vlanidvalue":    v.OuterVlanidvalue,
			"rate_limit_1":         rateLimit1,
			"source_mac":           v.SourceMac,
			"source_macmask":       v.SourceMacmask,
		})

	return objVal, diags
}

func (v MacEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(MacEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DestinationMac.Equal(other.DestinationMac) {
		return false
	}

	if !v.DestinationMacmask.Equal(other.DestinationMacmask) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.Log.Equal(other.Log) {
		return false
	}

	if !v.OuterVlanidoperator.Equal(other.OuterVlanidoperator) {
		return false
	}

	if !v.OuterVlanidrange.Equal(other.OuterVlanidrange) {
		return false
	}

	if !v.OuterVlanidvalue.Equal(other.OuterVlanidvalue) {
		return false
	}

	if !v.RateLimit1.Equal(other.RateLimit1) {
		return false
	}

	if !v.SourceMac.Equal(other.SourceMac) {
		return false
	}

	if !v.SourceMacmask.Equal(other.SourceMacmask) {
		return false
	}

	return true
}

func (v MacEntryValue) Type(ctx context.Context) attr.Type {
	return MacEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MacEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":               basetypes.StringType{},
		"destination_mac":      basetypes.StringType{},
		"destination_macmask":  basetypes.StringType{},
		"ethertype":            basetypes.StringType{},
		"log":                  basetypes.BoolType{},
		"outer_vlanidoperator": basetypes.StringType{},
		"outer_vlanidrange":    basetypes.StringType{},
		"outer_vlanidvalue":    basetypes.StringType{},
		"rate_limit_1": basetypes.ObjectType{
			AttrTypes: RateLimit1Value{}.AttributeTypes(ctx),
		},
		"source_mac":     basetypes.StringType{},
		"source_macmask": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RateLimit1Type{}

type RateLimit1Type struct {
	basetypes.ObjectType
}

func (t RateLimit1Type) Equal(o attr.Type) bool {
	other, ok := o.(RateLimit1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RateLimit1Type) String() string {
	return "RateLimit1Type"
}

func (t RateLimit1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return nil, diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return nil, diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return nil, diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RateLimit1Value{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimit1ValueNull() RateLimit1Value {
	return RateLimit1Value{
		state: attr.ValueStateNull,
	}
}

func NewRateLimit1ValueUnknown() RateLimit1Value {
	return RateLimit1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRateLimit1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RateLimit1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RateLimit1Value Attribute Value",
				"While creating a RateLimit1Value value, a missing attribute value was detected. "+
					"A RateLimit1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimit1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RateLimit1Value Attribute Type",
				"While creating a RateLimit1Value value, an invalid attribute value was detected. "+
					"A RateLimit1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimit1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RateLimit1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RateLimit1Value Attribute Value",
				"While creating a RateLimit1Value value, an extra attribute value was detected. "+
					"A RateLimit1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RateLimit1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRateLimit1ValueUnknown(), diags
	}

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return NewRateLimit1ValueUnknown(), diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return NewRateLimit1ValueUnknown(), diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return NewRateLimit1ValueUnknown(), diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewRateLimit1ValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewRateLimit1ValueUnknown(), diags
	}

	return RateLimit1Value{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimit1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RateLimit1Value {
	object, diags := NewRateLimit1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRateLimit1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RateLimit1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRateLimit1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRateLimit1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRateLimit1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRateLimit1ValueMust(RateLimit1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RateLimit1Type) ValueType(ctx context.Context) attr.Value {
	return RateLimit1Value{}
}

var _ basetypes.ObjectValuable = RateLimit1Value{}

type RateLimit1Value struct {
	BurstSize            basetypes.Int64Value  `tfsdk:"burst_size"`
	EntrySpecificPolicer basetypes.BoolValue   `tfsdk:"entry_specific_policer"`
	PeakRate             basetypes.Int64Value  `tfsdk:"peak_rate"`
	Scope                basetypes.StringValue `tfsdk:"scope"`
	state                attr.ValueState
}

func (v RateLimit1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["entry_specific_policer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["peak_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.BurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["burst_size"] = val

		val, err = v.EntrySpecificPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entry_specific_policer"] = val

		val, err = v.PeakRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peak_rate"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RateLimit1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RateLimit1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RateLimit1Value) String() string {
	return "RateLimit1Value"
}

func (v RateLimit1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"burst_size":             v.BurstSize,
			"entry_specific_policer": v.EntrySpecificPolicer,
			"peak_rate":              v.PeakRate,
			"scope":                  v.Scope,
		})

	return objVal, diags
}

func (v RateLimit1Value) Equal(o attr.Value) bool {
	other, ok := o.(RateLimit1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BurstSize.Equal(other.BurstSize) {
		return false
	}

	if !v.EntrySpecificPolicer.Equal(other.EntrySpecificPolicer) {
		return false
	}

	if !v.PeakRate.Equal(other.PeakRate) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v RateLimit1Value) Type(ctx context.Context) attr.Type {
	return RateLimit1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RateLimit1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
